<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Sorter Layout</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel2: rgba(15,22,32,.65);
      --border: rgba(255,255,255,.10);
      --text: #e7eefc;
      --muted: rgba(231,238,252,.65);
      --muted2: rgba(231,238,252,.45);
      --shadow: 0 10px 30px rgba(0,0,0,.55);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --gap: 10px;
      --slot: 18px;
      --radius: 10px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 25% 0%, rgba(122,162,255,.12), transparent 60%),
        radial-gradient(900px 650px at 85% 20%, rgba(45,212,191,.10), transparent 60%),
        var(--bg);
    }

    /* ---------------- HEADER ---------------- */
    header {
      padding: 16px 18px 10px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: end;
      gap: 12px;
      flex-wrap: wrap;
    }

    header > .titleWrap {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
    }

    header > .centerControls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 18px;
    }

    .sub {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    input[type="search"],
    .btn {
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
    }

    input[type="search"] {
      min-width: 300px;
    }

    .btn {
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(255,255,255,.09);
    }

    /* ---------------- MAIN LAYOUT ---------------- */
    main {
      padding: 0 18px 18px;
      display: grid;
      grid-template-columns: 300px 1fr 280px;
      gap: 14px;
      align-items: start;
    }

    .panel {
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
    }

    /* ---------------- DIRECTORY ---------------- */
    .dir {
      padding: 10px;
      max-height: calc(100vh - 120px);
      overflow: auto;
    }

    .dirHeader {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 6px 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      margin-bottom: 10px;
    }

    .title {
      font-size: 13px;
      font-weight: 600;
    }

    .meta {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    details.cat {
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      margin: 8px 4px;
      background: rgba(255,255,255,.03);
    }

    summary {
      cursor: pointer;
      padding: 10px;
      display: flex;
      justify-content: space-between;
    }

    .catName {
      font-size: 12px;
      font-weight: 600;
    }

    .count {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    .items {
      padding: 0 10px 10px;
      display: grid;
      gap: 6px;
    }

    .itemBtn {
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px;
      padding: 7px 8px;
      text-align: left;
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
    }

    .itemBtn small {
      font-family: var(--mono);
      color: var(--muted2);
    }

    /* ---------------- BOARD ---------------- */
    .board {
      padding: 12px;
      overflow: auto;
    }

    .columns {
      display: flex;
      gap: var(--gap);
      align-items: flex-start;
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 110px;
    }

    /* ---------------- POD ---------------- */
    .pod {
      background: rgba(255,255,255,.04);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .pod.selected {
      outline: 2px solid rgba(122,162,255, 0.6);
      outline-offset: 2px;
    }

    .wall {
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 8px;
      background: rgba(255,255,255,.03);
      padding: 4px;
      margin-top: 10px;
    }

    /* FIXED HEADER HEIGHT — KEY ALIGNMENT FIX */
    .podHeader {
      min-height: 42px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    .podId {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
    }

    .podCat {
      font-size: 11px;
      color: var(--muted2);
      white-space: normal;
      word-break: break-word;
    }

    /* ---------------- SLOT GRID ---------------- */
    .grid {
      display: grid;
      grid-template-columns: repeat(3, var(--slot));
      grid-template-rows: repeat(3, var(--slot));
      gap: 6px;
      justify-content: center;
    }

    .slot {
      width: var(--slot);
      height: var(--slot);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      cursor: pointer;
      position: relative;
    }

    .slot.unused {
      opacity: 0.35;
      cursor: default;
    }

    .slot.hasItem::after {
      content: "";
      position: absolute;
      right: 3px;
      bottom: 3px;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: #fff;
    }

    .slot.selected {
      box-shadow: 0 0 0 2px rgba(45,212,191,.6);
    }

    /* ---------------- DETAILS ---------------- */
    .details {
      padding: 12px 14px;
      max-height: calc(100vh - 120px);
      overflow: auto;
    }

    .details h2 {
      margin: 0;
      font-size: 14px;
    }

    .kv {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 6px 10px;
      font-family: var(--mono);
      font-size: 12px;
      margin-top: 10px;
    }

    .k { color: var(--muted); }

    /* ---------------- RESPONSIVE ---------------- */
    @media (max-width: 1300px) {
      main { grid-template-columns: 1fr; }
      .dir, .board, .details { max-height: none; }
    }

    @media (max-width: 700px) {
      header {
        grid-template-columns: 1fr;
        justify-items: center;
        text-align: center;
      }
      .titleWrap { align-items: center; }
    }
  </style>
</head>
<body>
<header>
  <div class="titleWrap">
    <h1>Minecraft Sorter Layout</h1>
    <div class="sub">Search filters the directory + layout. Click to view details.</div>
  </div>

  <div class="centerControls">
    <input id="search" type="search" placeholder="Search item or category…" />
    <button class="btn" id="clear">Clear</button>
  </div>
</header>

<main>
  <section class="panel dir">
    <div class="dirHeader">
      <div class="title">Directory</div>
      <div class="meta" id="dirMeta">—</div>
    </div>
    <div id="dirList"></div>
  </section>

  <section class="panel board">
    <div id="walls"></div>
    <div class="status" id="status"></div>
  </section>

  <section class="panel details" id="details">
    <h2>Selection</h2>
    <div class="kv">
      <div class="k">ChestID</div><div id="dChest">—</div>
      <div class="k">Category</div><div id="dCat">—</div>
      <div class="k">Description</div><div id="dDesc">—</div>
    </div>
  </section>
</main>

<script>
  // --------------------------
  // CSV LOADING + PARSING
  // --------------------------
  async function loadCSV(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
    return await res.text();
  }

  function parseCSV(text) {
    // minimal CSV parser supporting quotes + commas + "" escaping
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (inQuotes) {
        if (ch === '"' && next === '"') { cell += '"'; i++; }
        else if (ch === '"') inQuotes = false;
        else cell += ch;
      } else {
        if (ch === '"') inQuotes = true;
        else if (ch === ',') { row.push(cell); cell = ""; }
        else if (ch === '\n') { row.push(cell); rows.push(row); row = []; cell = ""; }
        else if (ch !== '\r') cell += ch;
      }
    }
    if (cell.length || row.length) { row.push(cell); rows.push(row); }

    const header = rows.shift().map(h => h.trim());
    const idx = Object.fromEntries(header.map((h, i) => [h, i]));

    return rows
      .filter(r => r.some(x => (x ?? "").trim() !== ""))
      .map(r => ({
        n: r[idx["#"]] ?? "",
        chestId: r[idx["ChestID"]] ?? "",
        col: r[idx["Column"]] ?? "",
        cluster: r[idx["Cluster"]] ?? "",
        number: r[idx["Number"]] ?? "",
        category: (r[idx["Categories"]] ?? "UNUSED").trim() || "UNUSED",
        desc: (r[idx["Description"]] ?? "").trim()
      }));
  }

  // --------------------------
  // WALL DEFINITIONS
  // --------------------------
  const WALLS = [
    { name: "East wall",  range: "A–I", letters: "ABCDEFGHI".split("") },
    { name: "South wall", range: "J–O", letters: "JKLMNO".split("") },
    { name: "West wall",  range: "P–X", letters: "PQRSTUVWX".split("") },
  ];

  function binId(letter, pod) { return `${letter}${pod}`; }
  function slotOrder() { return [1,2,3,4,5,6,7,8,9]; }

  function hashHue(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) h = (h * 31 + str.charCodeAt(i)) >>> 0;
    return h % 360;
  }

  function slotColor(category) {
    if (!category || category === "UNUSED") {
      return { bg: "rgba(255,255,255,.03)", border: "rgba(255,255,255,.08)" };
    }
    const hue = hashHue(category);
    return { bg: `hsla(${hue}, 70%, 55%, .18)`, border: `hsla(${hue}, 70%, 60%, .45)` };
  }

  // --------------------------
  // STATE
  // --------------------------
  const elWalls = document.getElementById("walls");
  const elStatus = document.getElementById("status");
  const elDirList = document.getElementById("dirList");
  const elDirMeta = document.getElementById("dirMeta");

  const elSearch = document.getElementById("search");
  const elClear = document.getElementById("clear");

  const elDChest = document.getElementById("dChest");
  const elDCat = document.getElementById("dCat");
  const elDDesc = document.getElementById("dDesc");

  let DATA = [];
  let INDEX = new Map();         // chestId -> row
  let CAT_INDEX = new Map();     // category -> Set(desc)
  let DESC_TO_CHEST = new Map(); // desc(lower) -> first chestId
  let SELECTED = null;
  let ACTIVE_FILTER = "";

  function buildIndexes(rows) {
    INDEX = new Map();
    CAT_INDEX = new Map();
    DESC_TO_CHEST = new Map();

    for (const r of rows) {
      INDEX.set(r.chestId, r);

      if (!CAT_INDEX.has(r.category)) CAT_INDEX.set(r.category, new Set());
      if (r.desc) CAT_INDEX.get(r.category).add(r.desc);

      const key = (r.desc || "").toLowerCase();
      if (key && !DESC_TO_CHEST.has(key)) DESC_TO_CHEST.set(key, r.chestId);
    }
  }

  function getRow(chestId) { return INDEX.get(chestId); }

  function setDetails(row) {
    if (!row) {
      elDChest.textContent = "—";
      elDCat.textContent = "—";
      elDDesc.textContent = "—";
      return;
    }
    elDChest.textContent = row.chestId || "—";
    elDCat.textContent = row.category || "—";
    elDDesc.textContent = row.desc || "—";
  }

  function clearSelection() {
    SELECTED = null;
    document.querySelectorAll(".slot.selected").forEach(x => x.classList.remove("selected"));
    document.querySelectorAll(".pod.selected").forEach(x => x.classList.remove("selected"));
    setDetails(null);
  }

  function matchesFilterText(s, q) {
    if (!q) return true;
    return (s || "").toLowerCase().includes(q);
  }

  function matchesRowFilter(row, q) {
    if (!q) return true;
    q = q.toLowerCase();
    return matchesFilterText(row.category, q) || matchesFilterText(row.desc, q);
  }

  function selectChest(chestId) {
    const row = getRow(chestId);
    if (!row) return;

    // update state first
    SELECTED = chestId;
    setDetails(row);

    // IMPORTANT: re-render so dim/opacity updates for the new selection
    // (renderAll() is fine too, but walls-only is usually enough)
    renderWalls();

    // Scroll to the newly selected slot (must happen after renderWalls)
    const slotEl = document.querySelector(`.slot[data-chest="${CSS.escape(chestId)}"]`);
    slotEl?.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
  }


  // --------------------------
  // DIRECTORY RENDER
  // --------------------------
  function renderDirectory() {
    elDirList.innerHTML = "";

    const cats = Array.from(CAT_INDEX.keys()).sort((a,b)=>a.localeCompare(b, undefined, { sensitivity: "base" }));

    let visibleCats = 0;
    let visibleItems = 0;

    for (const cat of cats) {
      const items = Array.from(CAT_INDEX.get(cat) || []).sort((a,b)=>a.localeCompare(b, undefined, { sensitivity: "base" }));

      const q = ACTIVE_FILTER.trim().toLowerCase();
      const catMatches = matchesFilterText(cat, q);
      const filteredItems = q ? items.filter(it => matchesFilterText(it, q) || catMatches) : items;

      if (!filteredItems.length && !catMatches) continue;

      visibleCats += 1;
      visibleItems += filteredItems.length;

      const det = document.createElement("details");
      det.className = "cat";
      if (q && (catMatches || filteredItems.length)) det.open = true;

      const sum = document.createElement("summary");

      const left = document.createElement("div");
      left.className = "catName";
      left.textContent = cat;

      const right = document.createElement("div");
      right.className = "count";
      right.textContent = `${filteredItems.length}`;

      sum.appendChild(left);
      sum.appendChild(right);
      det.appendChild(sum);

      const wrap = document.createElement("div");
      wrap.className = "items";

      for (const it of filteredItems) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "itemBtn";
        const chestId = DESC_TO_CHEST.get(it.toLowerCase()) ?? "—";
        btn.innerHTML = `<span>${escapeHtml(it)}</span><small>${chestId}</small>`;
        btn.addEventListener("click", () => {
          const cid = DESC_TO_CHEST.get(it.toLowerCase());
          if (cid) selectChest(cid);
        });
        wrap.appendChild(btn);
      }

      det.appendChild(wrap);
      elDirList.appendChild(det);
    }

    const suffix = ACTIVE_FILTER ? " (filtered)" : "";
    elDirMeta.textContent = `${visibleCats} cats • ${visibleItems} items${suffix}`;
  }

  function escapeHtml(s) {
    return (s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // --------------------------
  // LAYOUT RENDER (WALLS)
  // --------------------------
  function renderWalls() {
    elWalls.innerHTML = "";

    for (const wall of WALLS) {
      const wallWrap = document.createElement("div");
      wallWrap.className = "wall";

      const cols = document.createElement("div");
      cols.className = "columns";

      for (const letter of wall.letters) {
        const col = document.createElement("div");
        col.className = "col";

        for (const pod of [1, 2]) {
          const bin = binId(letter, pod);
          const podWrap = document.createElement("div");
          podWrap.className = "pod";

          // POD HEADER
          const head2 = document.createElement("div");
          head2.className = "podHeader";

          const podId = document.createElement("div");
          podId.className = "podId";
          podId.textContent = bin;

          const firstRow = getRow(`${bin}-1`);
          const cat = firstRow?.category ?? "UNUSED";

          const podCat = document.createElement("div");
          podCat.className = "podCat";
          podCat.title = cat;
          podCat.textContent = cat;

          head2.appendChild(podId);
          head2.appendChild(podCat);
          podWrap.appendChild(head2);

          // GRID
          const grid = document.createElement("div");
          grid.className = "grid";

          let podHasMatch = false;

          for (const n of slotOrder()) {
            const chestId = `${bin}-${n}`;
            const row = getRow(chestId);

            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "slot";
            btn.dataset.chest = chestId;
            btn.setAttribute("aria-label", chestId);

            const category = row?.category ?? "UNUSED";
            const desc = row?.desc ?? "";

            if (category === "UNUSED") btn.classList.add("unused");
            if (desc) btn.classList.add("hasItem");

            const c = slotColor(category);
            btn.style.background = c.bg;
            btn.style.borderColor = c.border;

            const isMatch = row ? matchesRowFilter(row, ACTIVE_FILTER) : false;
            const isSelected = chestId === SELECTED;

            // DIM LOGIC
            if (ACTIVE_FILTER && row) {
              if (!isMatch || (SELECTED && !isSelected)) {
                btn.style.opacity = "0.22";
              }
            }

            if (isMatch) podHasMatch = true;

            // SELECTION
            if (isSelected) {
              btn.classList.add("selected");
              podWrap.classList.add("selected");
            }

            btn.addEventListener("click", () => {
              if (!row) return;
              selectChest(chestId);
            });

            grid.appendChild(btn);
          }

          // POD HIGHLIGHT
          const isSelectedPod = SELECTED?.startsWith(`${bin}-`);
          if (isSelectedPod || (!SELECTED && podHasMatch && ACTIVE_FILTER)) {
            // only highlight matches during an active filter
            podWrap.classList.add("selected");
          }

          podWrap.appendChild(grid);
          col.appendChild(podWrap);
        }

        cols.appendChild(col);
      }

      wallWrap.appendChild(cols);
      elWalls.appendChild(wallWrap);
    }
  }

  function renderAll() {
    renderDirectory();
    renderWalls();
  }

  async function reload() {
    elStatus.textContent = "Loading sorter_layout.csv…";
    try {
      const text = await loadCSV("sorter_layout.csv");
      DATA = parseCSV(text);
      buildIndexes(DATA);
      elStatus.textContent = "";
      clearSelection();
      renderAll();
    } catch (e) {
      elStatus.textContent = `ERROR: ${e.message}`;
      console.error(e);
    }
  }

  // --------------------------
  // SEARCH RESET BEHAVIOR
  // --------------------------
  function resetFilterAndView() {
    elSearch.value = "";
    ACTIVE_FILTER = "";
    clearSelection();
    renderAll();
  }

  // Typing/backspacing
  elSearch.addEventListener("input", () => {
    const v = elSearch.value.trim();
    if (v === "") {
      resetFilterAndView();
      return;
    }
    ACTIVE_FILTER = v;
    renderAll();
  });

  // Clicking the built-in "x" clear icon (type="search")
  elSearch.addEventListener("search", () => {
    if (elSearch.value.trim() === "") resetFilterAndView();
  });

  // Clear button
  elClear.addEventListener("click", resetFilterAndView);

  // initial load
  reload();
</script>
</body>
</html>
